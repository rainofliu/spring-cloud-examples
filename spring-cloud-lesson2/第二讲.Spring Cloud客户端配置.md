# Spring Environment

`Environment` 是⼀种在**容器**内以 **配置**（Profile） 和 **属性**（Properties） 为模型的应⽤环境**抽象**整
合。

> Environment将Profile和Properties抽象起来，整合成一个API。

`Environment`: `PropertySources` =  1:1



`PropertySources`: `PropertySource` = 1:N

[0] `PropertySource` （Map）

​	spring.application.name = spring-cloud-config-client

[1] `PropertySource`（Map）

​	spring.application.name = spring-cloud-config-client-demo

```java
public interface Environment extends PropertyResolver {
    
    String[] getActiveProfiles();
    
    String[] getDefaultProfiles();
    
    String[] getDefaultProfiles();
    
    //有一个定义的废弃方法，忽略
    
    boolean acceptsProfiles(Profiles profiles);
    
```



Spring Framework 提供了两种 Environment 的实现，即

+ ⼀般应⽤ ： `StandardEnvironment`

  ```java
  public class StandardEnvironment extends AbstractEnvironment {
  
  	/** System environment property source name: {@value}. */
  	public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = "systemEnvironment";
  
  	/** JVM system properties property source name: {@value}. */
  	public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = "systemProperties";
      
      @Override
  	protected void customizePropertySources(MutablePropertySources propertySources) {
          
  		propertySources.addLast(new MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
          
  		propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));
  	}
  ```

  

+ Web 应⽤： `StandardServletEnvironment` 

  ```java
  public class StandardServletEnvironment extends StandardEnvironment implements ConfigurableWebEnvironment {
  
  	/** Servlet context init parameters property source name: {@value}. */
  	public static final String SERVLET_CONTEXT_PROPERTY_SOURCE_NAME = "servletContextInitParams";
  
  	/** Servlet config init parameters property source name: {@value}. */
  	public static final String SERVLET_CONFIG_PROPERTY_SOURCE_NAME = "servletConfigInitParams";
  
  	/** JNDI property source name: {@value}. */
  	public static final String JNDI_PROPERTY_SOURCE_NAME = "jndiProperties";
      
      @Override
  	protected void customizePropertySources(MutablePropertySources propertySources) {
  		propertySources.addLast(new StubPropertySource(SERVLET_CONFIG_PROPERTY_SOURCE_NAME));
  		propertySources.addLast(new StubPropertySource(SERVLET_CONTEXT_PROPERTY_SOURCE_NAME));
  		if (JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable()) {
  			propertySources.addLast(new JndiPropertySource(JNDI_PROPERTY_SOURCE_NAME));
  		}
  		super.customizePropertySources(propertySources);
  	}
  
  	@Override
  	public void initPropertySources(@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {
  		WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig);
  	}
  ```

  > 该类继承了StandardEnvironment类，重写了customizePropertySources方法；实现了ConfigurableWebEnvironment接口，重写了initPropertySources方法。

看一下`Environment`体系的类图：

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture8.png)

由上面的类图，我们可以看到：`Environment`是一个根接口，`ConfigurableEnvironment`接口继承了它，而`AbstractEnvironment`是一个抽象类，实现了`ConfigurableEnvironment`中的抽象方法，然后具体到实例化的时候，也就是我们上面引出的 `StandardEnvironment`和`StandardServletEnvironment` 

## 配置(Profile)

在 Spring 容器， `Profile` 是⼀种命名的 Bean 定义逻辑组。 

应⽤程序可通过调⽤ `ConfigurableEnvironment`接⼝控制 `Profile` 的激活，如：
+ `setActiveProfiles(String…)`多个参数

+ `addActiveProfile(String)`

+ `setDefaultProfiles(String…)` 多个参数

  

> 这一讲学到了关于学习新知识的方法，就是去阅读官方的文档，英语如果欠佳，就去找中文版的官方文档。长远角度，是一定要学好英语，并努力达到看英文文档不吃力的地步。

> 一切都源于官方文档和源码



我们来看一下`ConfigurableEnvironment` 接口的源码:



```java
public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver {
    //该方法有多个参数
    void setActiveProfiles(String... profiles);
    
    void addActiveProfile(String profile);
    
    void setDefaultProfiles(String... profiles);
    
    
    
    MutablePropertySources getPropertySources();
    
    Map<String, Object> getSystemProperties();
    
    Map<String, Object> getSystemEnvironment();
    
    void merge(ConfigurableEnvironment parent);
     
    
```

> 其实接口本身无意义，关键在于接口定了一套标准，给实现它的子类来具体化标准。也就是说接口搭了一个架子，交给子类登台唱戏。
>
> 再引申一下，注解和xml配置文件都是元数据，本身并没有意义，但是框架识别了这些元数据，就让元数据有了意义，发挥出自己的作用。

**小葵花课堂** :关于Spring的框架设计，有一个很明显的特点

比如：`ConfigurableEnvironment`代表可配置的环境，`ConfigurableApplicationContext`代表可配置的上下文；

本来`Environment`和`ApplicationContext`是俩父接口，但加了**Configurable**前缀以后，就变成可配置的环境和上下文了。



> 重点看一下ConfigurableEnvironment的getProperties方法

`MutablePropertySources getPropertySources();`

我们点击`MutablePropertySources`进去看一下：

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture12.png)

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture3.png)

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture4.png)

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture5.png)

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture6.png)

…..其余代码不贴了。



> MutablePropertySources中的Mutable表示容易变化的

## 属性(Properties)

### 概述

**属性**⼜称之为**配置项**， `Key-Value`的形式。在 Spring 应⽤中常⽤作占位符（Placeholder），⽽在
API 层⾯， Spring Framework 如下抽象来表述：

+ **组合**属性： `PropertySources`
+ **单⼀**属性： `PropertySource` 

> 1. 关于配置项，我们不希望写的固定，所以需要写在配置文件中方便修改。
>
> 2. 另外，也可以在idea的启动参数中配置属性

1. 我们跟着`MutablePropertySources`类看一下，它实现了`PropertySources`接口

```java
public interface PropertySources extends Iterable<PropertySource<?>> {

	/**
	 * Return a sequential {@link Stream} containing the property sources.
	 * @since 5.1
	 */
	default Stream<PropertySource<?>> stream() {
		return StreamSupport.stream(spliterator(), false);
	}

	/**
	 * Return whether a property source with the given name is contained.
	 * @param name the {@linkplain PropertySource#getName() name of the property source} to find
	 */
	boolean contains(String name);

	/**
	 * Return the property source with the given name, {@code null} if not found.
	 * @param name the {@linkplain PropertySource#getName() name of the property source} to find
	 */
	@Nullable
	PropertySource<?> get(String name);

}

```

​	我们可以看到`PropertySources`和`PropertySource`之间是1：N的关系。

2. 接着分析下`MutablePropertySources`的代码：

```java

package org.springframework.core.env;

import java.util.Iterator;
import java.util.List;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Stream;

import org.springframework.lang.Nullable;


public class MutablePropertySources implements PropertySources {
    //1.用CopyOnWriteArrayList这样一个线程安全的集合来存储PropertySource<?>集合
	private final List<PropertySource<?>> propertySourceList = new CopyOnWriteArrayList<>();


	/**
	 * Create a new {@link MutablePropertySources} object.
	 */
	public MutablePropertySources() {
	}

	/**
	 * Create a new {@code MutablePropertySources} from the given propertySources
	 * object, preserving the original order of contained {@code PropertySource} objects.
	 */
	public MutablePropertySources(PropertySources propertySources) {
		this();
		for (PropertySource<?> propertySource : propertySources) {
			addLast(propertySource);
		}
	}

   //2.集合获取迭代器对象Iterator
	@Override
	public Iterator<PropertySource<?>> iterator() {
		return this.propertySourceList.iterator();
	}

	@Override
	public Spliterator<PropertySource<?>> spliterator() {
		return Spliterators.spliterator(this.propertySourceList, 0);
	}

	@Override
	public Stream<PropertySource<?>> stream() {
		return this.propertySourceList.stream();
	}

	@Override
	public boolean contains(String name) {
		return this.propertySourceList.contains(PropertySource.named(name));
	}

	@Override
	@Nullable
	public PropertySource<?> get(String name) {
		int index = this.propertySourceList.indexOf(PropertySource.named(name));
		return (index != -1 ? this.propertySourceList.get(index) : null);
	}

	//3.下面4个方法都是按照指定位置添加PropertySource
    
	/**将PropertySource添加到propertySourceList的首位
	 * Add the given property source object with highest precedence.
	 */
	public void addFirst(PropertySource<?> propertySource) {
		removeIfPresent(propertySource);
		this.propertySourceList.add(0, propertySource);
	}

	/**
	 * Add the given property source object with lowest precedence.
	 */
	public void addLast(PropertySource<?> propertySource) {
		removeIfPresent(propertySource);
		this.propertySourceList.add(propertySource);
	}

	/**
	 * Add the given property source object with precedence immediately higher
	 * than the named relative property source.
	 */
	public void addBefore(String relativePropertySourceName, PropertySource<?> propertySource) {
		assertLegalRelativeAddition(relativePropertySourceName, propertySource);
		removeIfPresent(propertySource);
		int index = assertPresentAndGetIndex(relativePropertySourceName);
		addAtIndex(index, propertySource);
	}

	/**
	 * Add the given property source object with precedence immediately lower
	 * than the named relative property source.
	 */
	public void addAfter(String relativePropertySourceName, PropertySource<?> propertySource) {
		assertLegalRelativeAddition(relativePropertySourceName, propertySource);
		removeIfPresent(propertySource);
		int index = assertPresentAndGetIndex(relativePropertySourceName);
		addAtIndex(index + 1, propertySource);
	}

	/**
	 * Return the precedence of the given property source, {@code -1} if not found.
	 */
	public int precedenceOf(PropertySource<?> propertySource) {
		return this.propertySourceList.indexOf(propertySource);
	}

	/**
	 * Remove and return the property source with the given name, {@code null} if not found.
	 * @param name the name of the property source to find and remove
	 */
	@Nullable
	public PropertySource<?> remove(String name) {
		int index = this.propertySourceList.indexOf(PropertySource.named(name));
		return (index != -1 ? this.propertySourceList.remove(index) : null);
	}

	/**
	 * Replace the property source with the given name with the given property source object.
	 * @param name the name of the property source to find and replace
	 * @param propertySource the replacement property source
	 * @throws IllegalArgumentException if no property source with the given name is present
	 * @see #contains
	 */
	public void replace(String name, PropertySource<?> propertySource) {
		int index = assertPresentAndGetIndex(name);
		this.propertySourceList.set(index, propertySource);
	}

	/**
	 * Return the number of {@link PropertySource} objects contained.
	 */
	public int size() {
		return this.propertySourceList.size();
	}

	@Override
	public String toString() {
		return this.propertySourceList.toString();
	}

	/**
	 * Ensure that the given property source is not being added relative to itself.
	 */
	protected void assertLegalRelativeAddition(String relativePropertySourceName, PropertySource<?> propertySource) {
		String newPropertySourceName = propertySource.getName();
		if (relativePropertySourceName.equals(newPropertySourceName)) {
			throw new IllegalArgumentException(
					"PropertySource named '" + newPropertySourceName + "' cannot be added relative to itself");
		}
	}

	/**
	 * Remove the given property source if it is present.
	 */
	protected void removeIfPresent(PropertySource<?> propertySource) {
		this.propertySourceList.remove(propertySource);
	}

	/**
	 * Add the given property source at a particular index in the list.
	 */
	private void addAtIndex(int index, PropertySource<?> propertySource) {
		removeIfPresent(propertySource);
		this.propertySourceList.add(index, propertySource);
	}

	/**
	 * Assert that the named property source is present and return its index.
	 * @param name {@linkplain PropertySource#getName() name of the property source} to find
	 * @throws IllegalArgumentException if the named property source is not present
	 */
	private int assertPresentAndGetIndex(String name) {
		int index = this.propertySourceList.indexOf(PropertySource.named(name));
		if (index == -1) {
			throw new IllegalArgumentException("PropertySource named '" + name + "' does not exist");
		}
		return index;
	}

}

```

3. 接着看一个`PropertySource<T>`抽象类

```java

package org.springframework.core.env;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;


public abstract class PropertySource<T> {

	protected final Log logger = LogFactory.getLog(getClass());

	protected final String name;

	protected final T source;


	/**
	 * Create a new {@code PropertySource} with the given name and source object.
	 */
	public PropertySource(String name, T source) {
		Assert.hasText(name, "Property source name must contain at least one character");
		Assert.notNull(source, "Property source must not be null");
		this.name = name;
		this.source = source;
	}

	/**
	 * Create a new {@code PropertySource} with the given name and with a new
	 * {@code Object} instance as the underlying source.
	 * <p>Often useful in testing scenarios when creating anonymous implementations
	 * that never query an actual source but rather return hard-coded values.
	 */
	@SuppressWarnings("unchecked")
	public PropertySource(String name) {
		this(name, (T) new Object());
	}


	/**
	 * Return the name of this {@code PropertySource}.
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Return the underlying source object for this {@code PropertySource}.
	 */
	public T getSource() {
		return this.source;
	}

	/**
	 * Return whether this {@code PropertySource} contains the given name.
	 * <p>This implementation simply checks for a {@code null} return value
	 * from {@link #getProperty(String)}. Subclasses may wish to implement
	 * a more efficient algorithm if possible.
	 * @param name the property name to find
	 */
	public boolean containsProperty(String name) {
		return (getProperty(name) != null);
	}

	/**
	 * Return the value associated with the given name,
	 * or {@code null} if not found.
	 * @param name the property to find
	 * @see PropertyResolver#getRequiredProperty(String)
	 */
	@Nullable
	public abstract Object getProperty(String name);


	/**
	 * This {@code PropertySource} object is equal to the given object if:
	 * <ul>
	 * <li>they are the same instance
	 * <li>the {@code name} properties for both objects are equal
	 * </ul>
	 * <p>No properties other than {@code name} are evaluated.
	 */
	@Override
	public boolean equals(Object other) {
		return (this == other || (other instanceof PropertySource &&
				ObjectUtils.nullSafeEquals(this.name, ((PropertySource<?>) other).name)));
	}

	/**
	 * Return a hash code derived from the {@code name} property
	 * of this {@code PropertySource} object.
	 */
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.name);
	}

	/**
	 * Produce concise output (type and name) if the current log level does not include
	 * debug. If debug is enabled, produce verbose output including the hash code of the
	 * PropertySource instance and every name/value property pair.
	 * <p>This variable verbosity is useful as a property source such as system properties
	 * or environment variables may contain an arbitrary number of property pairs,
	 * potentially leading to difficult to read exception and log messages.
	 * @see Log#isDebugEnabled()
	 */
	@Override
	public String toString() {
		if (logger.isDebugEnabled()) {
			return getClass().getSimpleName() + "@" + System.identityHashCode(this) +
					" {name='" + this.name + "', properties=" + this.source + "}";
		}
		else {
			return getClass().getSimpleName() + " {name='" + this.name + "'}";
		}
	}


	/**
	 * Return a {@code PropertySource} implementation intended for collection comparison purposes only.
	 * <p>Primarily for internal use, but given a collection of {@code PropertySource} objects, may be
	 * used as follows:
	 * <pre class="code">
	 * {@code List<PropertySource<?>> sources = new ArrayList<PropertySource<?>>();
	 * sources.add(new MapPropertySource("sourceA", mapA));
	 * sources.add(new MapPropertySource("sourceB", mapB));
	 * assert sources.contains(PropertySource.named("sourceA"));
	 * assert sources.contains(PropertySource.named("sourceB"));
	 * assert !sources.contains(PropertySource.named("sourceC"));
	 * }</pre>
	 * The returned {@code PropertySource} will throw {@code UnsupportedOperationException}
	 * if any methods other than {@code equals(Object)}, {@code hashCode()}, and {@code toString()}
	 * are called.
	 * @param name the name of the comparison {@code PropertySource} to be created and returned.
	 */
	public static PropertySource<?> named(String name) {
		return new ComparisonPropertySource(name);
	}


	/**
	 * {@code PropertySource} to be used as a placeholder in cases where an actual
	 * property source cannot be eagerly initialized at application context
	 * creation time.  For example, a {@code ServletContext}-based property source
	 * must wait until the {@code ServletContext} object is available to its enclosing
	 * {@code ApplicationContext}.  In such cases, a stub should be used to hold the
	 * intended default position/order of the property source, then be replaced
	 * during context refresh.
	 * @see org.springframework.context.support.AbstractApplicationContext#initPropertySources()
	 * @see org.springframework.web.context.support.StandardServletEnvironment
	 * @see org.springframework.web.context.support.ServletContextPropertySource
	 */
	public static class StubPropertySource extends PropertySource<Object> {

		public StubPropertySource(String name) {
			super(name, new Object());
		}

		/**
		 * Always returns {@code null}.
		 */
		@Override
		@Nullable
		public String getProperty(String name) {
			return null;
		}
	}


	/**
	 * A {@code PropertySource} implementation intended for collection comparison
	 * purposes.
	 *
	 * @see PropertySource#named(String)
	 */
	static class ComparisonPropertySource extends StubPropertySource {

		private static final String USAGE_ERROR =
				"ComparisonPropertySource instances are for use with collection comparison only";

		public ComparisonPropertySource(String name) {
			super(name);
		}

		@Override
		public Object getSource() {
			throw new UnsupportedOperationException(USAGE_ERROR);
		}

		@Override
		public boolean containsProperty(String name) {
			throw new UnsupportedOperationException(USAGE_ERROR);
		}

		@Override
		@Nullable
		public String getProperty(String name) {
			throw new UnsupportedOperationException(USAGE_ERROR);
		}
	}

}

```



**备注**：`MutablePropertySources`实现了`PropertySources`接口，而`PropertySources`接口继承了`Iterable<PropertySource<?>>` 接口

### PropertySource：name&&source

+ 我们可以看到`PropertySource<T>`抽象类中含有一个`String`类型的`name`属性和T泛型的`source`属性

  ```java
  protected final String name;
  protected final T source;
  ```

  

+ 然后我们访问`localhost:8080/env`，如图所示：

  ```json
  {
  profiles:[],
  server.ports: - {
  local.server.port: 8080
  },
  servletContextInitParams:{},
  systemProperties: + {... },//省略不明
  systemEnvironment: + {... },//省略不明
  applicationConfig: [classpath:/application.properties]: - {
  endpoints.env.sensitive: "false",
  spring.application.name: "spring-cloud-config-client"
  },
  springCloudClientHostInfo: - {
  spring.cloud.client.hostname: "localhost",
  spring.cloud.client.ipAddress: "169.254.175.93"
  },
  defaultProperties:{}
  }
  
  ```

+ 看一下`MapPropertySource`以及`PropertiesPropertySource`

  ```java
  public class MapPropertySource extends EnumerablePropertySource<Map<String, Object>> {
  
  	public MapPropertySource(String name, Map<String, Object> source) {
  		super(name, source);
  	}
  
  
  	@Override
  	public Object getProperty(String name) {
  		return this.source.get(name);
  	}
  
  	@Override
  	public boolean containsProperty(String name) {
  		return this.source.containsKey(name);
  	}
  
  	@Override
  	public String[] getPropertyNames() {
  		return StringUtils.toStringArray(this.source.keySet());
  	}
  
  }
  
  ```

  > `MapPropertySource`类的有参构造器中，`name`是`String`类型，`source`是具体的`Map<String,Object>`类型

   

  ```java
  public class PropertiesPropertySource extends MapPropertySource {
  
  	@SuppressWarnings({"unchecked", "rawtypes"})
  	public PropertiesPropertySource(String name, Properties source) {
  		super(name, (Map) source);
  	}
  
  	protected PropertiesPropertySource(String name, Map<String, Object> source) {
  		super(name, source);
  	}
  
  }
  
  ```

  > `PropertiesPropertySource`类的有参构造器中，`name`是`String`类型，`source`是具体的`Properties`类型，而`Properties`其实也是个`Map`类型。

+ 到这里，我们截取一下`localhost:8080/env`的结果：

  ```json
  systemProperties: - {
  com.sun.management.jmxremote.authenticate: "false",
  java.runtime.name: "Java(TM) SE Runtime Environment",
  spring.output.ansi.enabled: "always",
  sun.boot.library.path: "C:\Program Files\Java\jdk1.8.0_161\jre\bin",
  java.vm.version: "25.161-b12",
  java.vm.vendor: "Oracle Corporation",
  java.vendor.url: "http://java.oracle.com/",
  java.rmi.server.randomIDs: "true",
  path.separator: ";",
  java.vm.name: "Java HotSpot(TM) 64-Bit Server VM",
  file.encoding.pkg: "sun.io",
  user.country: "CN",
  user.script: "",
  sun.java.launcher: "SUN_STANDARD",
  sun.os.patch.level: "",
  PID: "15792",
  com.sun.management.jmxremote.port: "5687",
  java.vm.specification.name: "Java Virtual Machine Specification",
  user.dir: "E:\eclipse projects\Spring Cloud Lesson SegmentFault\spring-cloud-lesson2",
  java.runtime.version: "1.8.0_161-b12",
  java.awt.graphicsenv: "sun.awt.Win32GraphicsEnvironment",
  org.jboss.logging.provider: "slf4j",
  java.endorsed.dirs: "C:\Program Files\Java\jdk1.8.0_161\jre\lib\endorsed",
  os.arch: "amd64",
  java.io.tmpdir: "C:\Users\ajin\AppData\Local\Temp\",
  line.separator: " ",
  java.vm.specification.vendor: "Oracle Corporation",
  user.variant: "",
      .....
      省略其他部分
  }
  ```

  > `systemProperties`就对应着`name`，而{。。。。}中的内容就是`source`，如上的json所示，source是`Map`形式。

> 到这里一切就很清楚了：一个`name`对应一个`source`，就组成了一个`PropertySource`，众多的`PropertySource`就组成了一个`PropertySources`

## Spring Boot的配置文件

### application.properties 或 application.xml



加载器：`PropertiesPropertySourceLoader`

> 加载器将`.properties`以及`.xml`文件加载成`PropertySource`

```java
/**
 * Strategy to load '.properties' files into a {@link PropertySource}.
 *
 * @author Dave Syer
 * @author Phillip Webb
 */
public class PropertiesPropertySourceLoader implements PropertySourceLoader {

	@Override
	public String[] getFileExtensions() {
		return new String[] { "properties", "xml" };
	}

	@Override
	public PropertySource<?> load(String name, Resource resource, String profile)
			throws IOException {
		if (profile == null) {
			Properties properties = PropertiesLoaderUtils.loadProperties(resource);
			if (!properties.isEmpty()) {
				return new PropertiesPropertySource(name, properties);
			}
		}
		return null;
	}

}
```



### application.yml 或者 application.yaml

加载器：`YamlPropertySourceLoader`

> 加载器将`yml`和`yaml`配置文件加载成`PropertySource`文件

```java
/**
 * Strategy to load '.yml' (or '.yaml') files into a {@link PropertySource}.
 *
 * @author Dave Syer
 * @author Phillip Webb
 * @author Andy Wilkinson
 */
public class YamlPropertySourceLoader implements PropertySourceLoader {

	@Override
	public String[] getFileExtensions() {
		return new String[] { "yml", "yaml" };
	}

	@Override
	public PropertySource<?> load(String name, Resource resource, String profile)
			throws IOException {
		if (ClassUtils.isPresent("org.yaml.snakeyaml.Yaml", null)) {
			Processor processor = new Processor(resource, profile);
			Map<String, Object> source = processor.process();
			if (!source.isEmpty()) {
				return new MapPropertySource(name, source);
			}
		}
		return null;
	}

	/**
	 * {@link YamlProcessor} to create a {@link Map} containing the property values.
	 * Similar to {@link YamlPropertiesFactoryBean} but retains the order of entries.
	 */
	private static class Processor extends YamlProcessor {

		Processor(Resource resource, String profile) {
			if (profile == null) {
				setMatchDefault(true);
				setDocumentMatchers(new SpringProfileDocumentMatcher());
			}
			else {
				setMatchDefault(false);
				setDocumentMatchers(new SpringProfileDocumentMatcher(profile));
			}
			setResources(resource);
		}

		@Override
		protected Yaml createYaml() {
			return new Yaml(new StrictMapAppenderConstructor(), new Representer(),
					new DumperOptions(), new Resolver() {
						@Override
						public void addImplicitResolver(Tag tag, Pattern regexp,
								String first) {
							if (tag == Tag.TIMESTAMP) {
								return;
							}
							super.addImplicitResolver(tag, regexp, first);
						}
					});
		}

		public Map<String, Object> process() {
			final Map<String, Object> result = new LinkedHashMap<String, Object>();
			process(new MatchCallback() {
				@Override
				public void process(Properties properties, Map<String, Object> map) {
					result.putAll(getFlattenedMap(map));
				}
			});
			return result;
		}

	}

}

```



### ConfigFileApplicationListener (相当重要)

在 `Spring Boot` 场景中，⽤于读取**默认**以及`Profile` 关联的配置⽂件（`application.properties`）

看一下`ConfigFileApplicationListener`代码：

```java
public class ConfigFileApplicationListener
		implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {
    ................
    private static final String DEFAULT_NAMES = "application";//留意
    ................
    @Override
	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
		return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)
				|| ApplicationPreparedEvent.class.isAssignableFrom(eventType);
	}
    ................
        /**
	 * Loads candidate property sources and configures the active profiles.
	 */
        private class Loader {
            //这个对象很重要
            private PropertySourcesLoader propertiesLoader;
            ......
        }
    ......
}
     
```

> 我们点进私有类Loader去看，我们注意下PropertySourcesLoader这个对象。

```java
public class PropertySourcesLoader {

	private static final Log logger = LogFactory.getLog(PropertySourcesLoader.class);

	private final MutablePropertySources propertySources;

	private final List<PropertySourceLoader> loaders;//留意
    ......
```

> 看下PropertySourceLoader

```java
public interface PropertySourceLoader {

	String[] getFileExtensions();

	PropertySource<?> load(String name, Resource resource, String profile)
			throws IOException;

}

```

> `PropertySourceLoader`接口有两个实现类`PropertiesPropertySourceLoader`和`YamlPropertySourceLoader`，这两个类作为**加载器**，分别将.properties/.xml和.yml/.yaml后缀的配置文件加载成`PropertySource`

# Spring 事件监听器

## 事件（Event）

### `ApplicationEvent`

```java
public abstract class ApplicationEvent extends EventObject {
    /** use serialVersionUID from Spring 1.2 for interoperability */
	private static final long serialVersionUID = 7099057708183571937L;

	/** System time when the event happened */
	private final long timestamp;


	/**
	 * Create a new ApplicationEvent.
	 * @param source the object on which the event initially occurred (never {@code null})
	 */
	public ApplicationEvent(Object source) {
		super(source);
		this.timestamp = System.currentTimeMillis();
	}


	/**
	 * Return the system time in milliseconds when the event happened.
	 */
	public final long getTimestamp() {
		return this.timestamp;
	}

}

```

```java
public class EventObject implements java.io.Serializable {

    private static final long serialVersionUID = 5516075349620653480L;

    /**
     * The object on which the Event initially occurred.
     */
    protected transient Object  source;

    public EventObject(Object source) {
        if (source == null)
            throw new IllegalArgumentException("null source");

        this.source = source;
    }

    /**
     * The object on which the Event initially occurred.
     *
     * @return   The object on which the Event initially occurred.
     */
    public Object getSource() {
        return source;
    }

    /**
     * Returns a String representation of this EventObject.
     *
     * @return  A a String representation of this EventObject.
     */
    public String toString() {
        return getClass().getName() + "[source=" + source + "]";
    }
}

```



##  事件监听器（EventListener）

### `ApplicationListener` 

```java
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {

	//处理监听到的事件
	void onApplicationEvent(E event);

}

```

`ApplicationListener`接口会监听到继承自`ApplicationEvent`的子类的泛型，然后调用`onApplicationEvent`方法来对监听到的事件进行处理

```java
package java.util;

/**
 * A tagging interface that all event listener interfaces must extend.
 * @since JDK1.1
 */
public interface EventListener {
}

```

真的只是一个接口，什么都不做；或许就是让子类去实现自己，然后做监听事件的工作。



再看一下`EventListener`注解（`@EventListener`）的源码：

```java
package org.springframework.context.event;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.context.ApplicationEvent;
import org.springframework.core.annotation.AliasFor;

/**
 * Annotation that marks a method as a listener for application events.
 * @author Stephane Nicoll
 * @since 4.2
 * @see EventListenerMethodProcessor
 */
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface EventListener {

	
	@AliasFor("classes")
	Class<?>[] value() default {};

	@AliasFor("value")
	Class<?>[] classes() default {};

	
	String condition() default "";

}

```

> 该注解让某个方法去监听时间，但是其Spring版本（Spring 4.2)过高，一般不直接使用它。



 

# env端点

## 请求 URI ：`/env`



1. 数据来源：`EnvironmentEndpoint`

```java
@ConfigurationProperties(prefix = "endpoints.env")
public class EnvironmentEndpoint extends AbstractEndpoint<Map<String, Object>> {

	private final Sanitizer sanitizer = new Sanitizer();

	/**
	 * Create a new {@link EnvironmentEndpoint} instance.
	 */
	public EnvironmentEndpoint() {
		super("env");//1.此处的id代表着通过/env来访问
	}

	public void setKeysToSanitize(String... keysToSanitize) {
		this.sanitizer.setKeysToSanitize(keysToSanitize);
	}
   //2.返回json
	@Override
	public Map<String, Object> invoke() {
		Map<String, Object> result = new LinkedHashMap<String, Object>();
		result.put("profiles", getEnvironment().getActiveProfiles());
		PropertyResolver resolver = getResolver();
		for (Entry<String, PropertySource<?>> entry : getPropertySourcesAsMap()
				.entrySet()) {
			PropertySource<?> source = entry.getValue();
			String sourceName = entry.getKey();
			if (source instanceof EnumerablePropertySource) {
				EnumerablePropertySource<?> enumerable = (EnumerablePropertySource<?>) source;
				Map<String, Object> properties = new LinkedHashMap<String, Object>();
				for (String name : enumerable.getPropertyNames()) {
					Object property = source.getProperty(name);
					Object resolved = property instanceof String
							? resolver.resolvePlaceholders((String) property) : property;
					properties.put(name, sanitize(name, resolved));
				}
				properties = postProcessSourceProperties(sourceName, properties);
				if (properties != null) {
					result.put(sourceName, properties);
				}
			}
		}
		return result;
	}
```



2. Controller 来源：`EnvironmentMvcEndpoint`

```java
@ConfigurationProperties(prefix = "endpoints.env")
public class EnvironmentMvcEndpoint extends EndpointMvcAdapter
		implements EnvironmentAware {

	private Environment environment;

	public EnvironmentMvcEndpoint(EnvironmentEndpoint delegate) {
		super(delegate);
	}
   //1.给我们自定义访问的(Controller层)
	@ActuatorGetMapping("/{name:.*}")
	@ResponseBody
	@HypermediaDisabled
	public Object value(@PathVariable String name) {
		if (!getDelegate().isEnabled()) {
			// Shouldn't happen - MVC endpoint shouldn't be registered when delegate's
			// disabled
			return getDisabledResponse();
		}
		return new NamePatternEnvironmentFilter(this.environment).getResults(name);
	}

	@Override
	public void setEnvironment(Environment environment) {
		this.environment = environment;
	}

	/**
	 * {@link NamePatternFilter} for the Environment source.
	 */
	private class NamePatternEnvironmentFilter extends NamePatternFilter<Environment> {

		NamePatternEnvironmentFilter(Environment source) {
			super(source);
		}

		@Override
		protected void getNames(Environment source, NameCallback callback) {
			if (source instanceof ConfigurableEnvironment) {
				getNames(((ConfigurableEnvironment) source).getPropertySources(),
						callback);
			}
		}

		private void getNames(PropertySources propertySources, NameCallback callback) {
			for (PropertySource<?> propertySource : propertySources) {
				if (propertySource instanceof EnumerablePropertySource) {
					EnumerablePropertySource<?> source = (EnumerablePropertySource<?>) propertySource;
					for (String name : source.getPropertyNames()) {
						callback.addName(name);
					}
				}
			}
		}

		@Override
		protected Object getOptionalValue(Environment source, String name) {
			Object result = getValue(name);
			if (result != null) {
				result = ((EnvironmentEndpoint) getDelegate()).sanitize(name, result);
			}
			return result;
		}

		@Override
		protected Object getValue(Environment source, String name) {
			Object result = getValue(name);
			if (result == null) {
				throw new NoSuchPropertyException("No such property: " + name);
			}
			return ((EnvironmentEndpoint) getDelegate()).sanitize(name, result);
		}

		private Object getValue(String name) {
			return ((EnvironmentEndpoint) getDelegate()).getResolver().getProperty(name,
					Object.class);
		}

	}

	/**
	 * Exception thrown when the specified property cannot be found.
	 */
	@SuppressWarnings("serial")
	@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "No such property")
	public static class NoSuchPropertyException extends RuntimeException {

		public NoSuchPropertyException(String string) {
			super(string);
		}

	}

}
```

> 我们可以通过发送Post请求到url来完成对应用程序配置的修改：
>
> 如：http://127.0.0.1:8080/env?spring.application.name=test-app
>
> 该Post请求会将我们的应用程序名改成test-app，可以通过http://localhost:8080/env/spring.application.name(Get请求)来验证



# Bootstrap配置

参考`BootstrapApplicationListener` 实现

```java
public class BootstrapApplicationListener
		implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {

	public static final String BOOTSTRAP_PROPERTY_SOURCE_NAME = "bootstrap";

	public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 5;

	public static final String DEFAULT_PROPERTIES = "defaultProperties";

	private int order = DEFAULT_ORDER;

	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
        //1.获取ConfigurableEnvironment
		ConfigurableEnvironment environment = event.getEnvironment();
		if (!environment.getProperty("spring.cloud.bootstrap.enabled", Boolean.class,
				true)) {
			return;
		}
		// don't listen to events in a bootstrap context
		if (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) {
			return;
		}
		ConfigurableApplicationContext context = null;
		String configName = environment
				.resolvePlaceholders("${spring.cloud.bootstrap.name:bootstrap}");
		for (ApplicationContextInitializer<?> initializer : event.getSpringApplication()
				.getInitializers()) {
			if (initializer instanceof ParentContextApplicationContextInitializer) {
				context = findBootstrapContext(
						(ParentContextApplicationContextInitializer) initializer,
						configName);
			}
		}
		if (context == null) {
			context = bootstrapServiceContext(environment, event.getSpringApplication(),
					configName);
		}
		apply(context, event.getSpringApplication(), environment);
	}
......
```



 

> 注：程序启动参数的加载逻辑：
>
> `SpringApplication#configurePropertySources()`

```java
	
	protected void configurePropertySources(ConfigurableEnvironment environment,
			String[] args) {
		MutablePropertySources sources = environment.getPropertySources();
		if (this.defaultProperties != null && !this.defaultProperties.isEmpty()) {
			sources.addLast(
					new MapPropertySource("defaultProperties", this.defaultProperties));
		}
		if (this.addCommandLineProperties && args.length > 0) {
			String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;
			if (sources.contains(name)) {
				PropertySource<?> source = sources.get(name);
				CompositePropertySource composite = new CompositePropertySource(name);
				composite.addPropertySource(new SimpleCommandLinePropertySource(
						name + "-" + args.hashCode(), args));
				composite.addPropertySource(source);
				sources.replace(name, composite);
			}
			else {
				sources.addFirst(new SimpleCommandLinePropertySource(args));
			}
		}
	}
```



# Bootstrap配置文件



> 通过官方文档和源码，可以获得对技术更深的理解

参考下`BootstrapApplicationListener`实现：

```java
public class BootstrapApplicationListener
		implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {

	public static final String BOOTSTRAP_PROPERTY_SOURCE_NAME = "bootstrap";
    //1.优先级
	public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 5;

	public static final String DEFAULT_PROPERTIES = "defaultProperties";

	private int order = DEFAULT_ORDER;

	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		if (!environment.getProperty("spring.cloud.bootstrap.enabled", Boolean.class,
				true)) {
			return;
		}
		// don't listen to events in a bootstrap context
		if (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) {
			return;
		}
		ConfigurableApplicationContext context = null;
        //2.留意
		String configName = environment
				.resolvePlaceholders("${spring.cloud.bootstrap.name:bootstrap}");
		for (ApplicationContextInitializer<?> initializer : event.getSpringApplication()
				.getInitializers()) {
			if (initializer instanceof ParentContextApplicationContextInitializer) {
				context = findBootstrapContext(
						(ParentContextApplicationContextInitializer) initializer,
						configName);
			}
		}
		if (context == null) {
			context = bootstrapServiceContext(environment, event.getSpringApplication(),
					configName);
		}
		apply(context, event.getSpringApplication(), environment);
	}

	private ConfigurableApplicationContext findBootstrapContext(
			ParentContextApplicationContextInitializer initializer, String configName) {
		Field field = ReflectionUtils
				.findField(ParentContextApplicationContextInitializer.class, "parent");
		ReflectionUtils.makeAccessible(field);
		ConfigurableApplicationContext parent = safeCast(
				ConfigurableApplicationContext.class,
				ReflectionUtils.getField(field, initializer));
		if (parent != null && !configName.equals(parent.getId())) {
			parent = safeCast(ConfigurableApplicationContext.class, parent.getParent());
		}
		return parent;
	}

```

`BootstrapApplicationListener`，是一个监听器，负责监听`ApplicationEnvironmentPreparedEvent`，还重写了`ApplicationListener`接口的`onApplicationEvent()`方法



> 下面的代码是获取配置文件的文件名

`String configName = environment.resolvePlaceholders("${spring.cloud.bootstrap.name:bootstrap}");`

当 `spring.cloud.bootstrap.name` 存在时，使用该配置项，否则，使用 "bootstrap" 作为默认



**例子1**：

+ application.properties

  `spring.application.name=spring-cloud-config-client`

+ bootstrap.properties

  `spring.application.name=spring-cloud-config-client-demo`

+ 重启应用，输入 http://localhost:8080/env，搜索`spring.application.name`

  ```json
  applicationConfig: [classpath:/application.properties]: - {
  endpoints.env.sensitive: "false",
  spring.application.name: "spring-cloud-config-client"
  },
  
  ......
  applicationConfig: [classpath:/bootstrap.properties]: - {
  spring.application.name: "spring-cloud-config-client-demo"
  },
  ```

  

+ 浏览器输入http://localhost:8080/env/spring.application.name

  ```json
  {
  spring.application.name: "spring-cloud-config-client"
  }
  ```

> 结论证明application.properties中的属性被保留了
>
> 主要原因是application.properties被装载成PropertySource的时候，排在前面
>
> **这个可以从下面的json看出来**：
>
> applicationConfig: [classpath:/application.properties]: - {
> endpoints.env.sensitive: "false",
> spring.application.name: "spring-cloud-config-client"
> },
>
> ......
> applicationConfig: [classpath:/bootstrap.properties]: - {
> spring.application.name: "spring-cloud-config-client-demo"
> },

**例子2**：

在`application.properties`中设置`spring.cloud.bootstrap.enabled=false`，尝试关闭Spring Cloud上下文，结果不成功；

因为`BootstrapApplicationListener` 加载实际早于 `ConfigFileApplicationListener`，所以Bootstrap上下文已经启动成功了，我们才用 ConfigFileApplicationListener去读取application.properties的配置属性



> 注意：`BootstrapApplicationListener` 加载实际早于 `ConfigFileApplicationListener`
>
> 原因是：
>
> `ConfigFileApplicationListener` 的 Order =  Ordered.HIGHEST_PRECEDENCE + 10（第十一位）
>
> `BootstrapApplicationListener`的 Order = Ordered.HIGHEST_PRECEDENCE + 5（第六位）



如果需要调整 控制 Bootstrap 上下文行为配置，需要更高优先级，也就是说 Order 需要  < Ordered.HIGHEST_PRECEDENCE + 5 **(越小越优先**)，比如使用程序启动参数：

```
--spring.cloud.bootstrap.enabled = false
```



此时我们关闭了Bootstrap上下文，自然bootstrap.properties配置文件就更没有加载；这时候访问浏览器http://localhost:8080/env：

```json
applicationConfig: [classpath:/application.properties]: - {
endpoints.env.sensitive: "false",
spring.application.name: "spring-cloud-config-client"
},
//没有bootstrap.properties
```

### 调整 Bootstrap 配置



#### 调整 Bootstrap 配置文件名称



调整程序启动参数

```
--spring.cloud.bootstrap.name=spring-cloud
```

bootstrap 配置文件名称发生了改变"spring-cloud"，现有三个文件：

- `application.properties`
  - **spring.application.name = spring-cloud-config-client**
- `bootstrap.properties`
  - spring.application.name = spring-cloud-config-client-demo
- `spring-cloud.properties`
  - **spring.application.name = spring-cloud**



浏览器结果如下：

```json
"applicationConfig: [classpath:/application.properties]": {
    "spring.cloud.bootstrap.enabled": "false",
    "endpoints.env.sensitive": "false",
    "spring.application.name": "spring-cloud-config-client"
  },
  ...
  "applicationConfig: [classpath:/spring-cloud.properties]": {
    "spring.application.name": "spring-cloud-config-client"
  }
```



#### 调整 Bootstrap 配置文件路径



保留 **Bootstrap 配置文件名称**  程序启动参数

```
--spring.cloud.bootstrap.name=spring-cloud
```



调整 **Bootstrap 配置文件路径** 程序启动参数：

```properties
--spring.cloud.bootstrap.location=config
```



现有四个文件：

* `application.properties`
  * **spring.application.name = spring-cloud-config-client**
* `bootstrap.properties`
  * spring.application.name = spring-cloud-config-client-demo
* `spring-cloud.properties`
  * **spring.application.name = spring-cloud**
* `config/spring-cloud.properties`
  * **spring.application.name = spring-cloud-2**



实际结果：

```json
"applicationConfig: [classpath:/application.properties]": {
    "spring.cloud.bootstrap.enabled": "false",
    "endpoints.env.sensitive": "false",
    "spring.application.name": "spring-cloud-config-client"
  },
  ...
  "applicationConfig: [classpath:/config/spring-cloud.properties]": {
    "spring.application.name": "spring-cloud-config-client"
  },
  "applicationConfig: [classpath:/spring-cloud.properties]": {
    "spring.application.name": "spring-cloud-config-client" 
  },
```



#### 覆盖远程配置属性



默认情况，Spring Cloud 是允许覆盖的，`spring.cloud.config.allowOverride=true`



通过程序启动参数，调整这个值为"**false**"

```properties
--spring.cloud.config.allowOverride=false
```



启动后，重新Postman 发送 POST 请求，调整`spring.application.name` 值为 "**spring-cloud-new**"

> 注意官方文档的说明：the remote property source has to grant it permission by setting `spring.cloud.config.allowOverride=true` (it doesn’t work to set this locally).





#### 自定义 Bootstrap 配置



1. 创建`META-INF/spring.factories`文件（类似于 Spring Boot 自定义 Starter）

2. 自定义 Bootstrap 配置 Configuration

   ```java
   import org.springframework.context.ApplicationContextInitializer;
   import org.springframework.context.ConfigurableApplicationContext;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.core.env.ConfigurableEnvironment;
   import org.springframework.core.env.MapPropertySource;
   import org.springframework.core.env.MutablePropertySources;
   import org.springframework.core.env.PropertySource;
   
   import java.util.HashMap;
   import java.util.Map;
   
   /**
    * Bootstrap 配置 Bean
    *
    * @author <a href="mailto:mercyblitz@gmail.com">Mercy</a>
    * @since Configuration
    */
   @Configuration
   public class MyConfiguration implements ApplicationContextInitializer {
   
       @Override
       public void initialize(ConfigurableApplicationContext applicationContext) {
           
           // 从 ConfigurableApplicationContext 获取 ConfigurableEnvironment 实例
           ConfigurableEnvironment environment = applicationContext.getEnvironment();
           // 获取 PropertySources
           MutablePropertySources propertySources = environment.getPropertySources();
           // 定义一个新的 PropertySource，并且放置在首位
           propertySources.addFirst(createPropertySource());
   
       }
   
       private PropertySource createPropertySource() {
   
           Map<String, Object> source = new HashMap<>();
   
           source.put("name", "小马哥");
   
           PropertySource propertySource = new MapPropertySource("my-property-source", source);
   
           return propertySource;
   
       }
   }
   ```

   

3. 配置`META-INF/spring.factories`文件，关联Key `org.springframework.cloud.bootstrap.BootstrapConfiguration`

   ```pro
   org.springframework.cloud.bootstrap.BootstrapConfiguration= \
    com.ajin.springcloudlesson2.bootstrap.MyConfiguration
   ```

   



#### 自定义 Bootstrap 配置属性源





1. 实现`PropertySourceLocator`

   ```java
   import org.springframework.cloud.bootstrap.config.PropertySourceLocator;
   import org.springframework.core.env.*;
   
   import java.util.HashMap;
   import java.util.Map;
   
   /**
    * 自定义 {@link PropertySourceLocator} 实现
    *
    * @author <a href="mailto:mercyblitz@gmail.com">Mercy</a>
    * @since PropertySourceLocator
    */
   public class MyPropertySourceLocator implements PropertySourceLocator {
   
       @Override
       public PropertySource<?> locate(Environment environment) {
   
           if (environment instanceof ConfigurableEnvironment) {
   
               ConfigurableEnvironment configurableEnvironment = ConfigurableEnvironment.class.cast(environment);
   
               // 获取 PropertySources
               MutablePropertySources propertySources = configurableEnvironment.getPropertySources();
               // 定义一个新的 PropertySource，并且放置在首位
               propertySources.addFirst(createPropertySource());
   
           }
           return null;
       }
   
       private PropertySource createPropertySource() {
   
           Map<String, Object> source = new HashMap<>();
   
           source.put("spring.application.name", "小马哥的 Spring Cloud 程序");
           // 设置名称和来源
           PropertySource propertySource = new MapPropertySource("over-bootstrap-property-source", source);
   
           return propertySource;
   
       }
   }
   ```

   

   2. 配置`META-INF/spring.factories`

      ```java
      org.springframework.cloud.bootstrap.BootstrapConfiguration= \
      com.ajin.springcloudlesson2.boostrap.MyConfiguration,\
      com.ajin.springcloudlesson2.boostrap.MyPropertySourceLocator
      ```

   

   

   运行结果：

   ```json   
   	profiles:[],
   	server.ports: - {
   	local.server.port: 8080
    	 },
   	"spring-clou-new-properties": - {
   	小马哥: "Alibaba"
   	},
    	"over-bootstrap-property-source": - {
   	spring.application.name: "小马哥的 Spring Cloud 程序"
   	},
   	"commandLineArgs": - {
   	spring.cloud.config.allowOverride: "false",
   	spring.cloud.bootstrap.location: "config",
   	spring.cloud.bootstrap.name: "spring-cloud"
    	 },
   ```

   

   

   > 这个例子，覆盖了其他配置文件（.properties）中配置的`spring.application.name`属性

   

